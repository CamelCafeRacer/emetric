#!/usr/bin/env python
import os
import sys
import getopt
import itertools
import pygtk
pygtk.require('2.0')
import gtk


import numpy as np
import matplotlib.pyplot as plt
from matplotlib import mlab
from matplotlib.ticker import EngFormatter

class Usage(Exception):
    def __init__(self,msg):
        self.msg = msg
def usage():
    return """
plotr.py [options]

This will display a list of 'interesting' fields in which you can compare in line graphs.  It works best when you only compare two metrics. If you try for more, then good luck.

-h|--help:
    print this help message

-d file|--data=file :
    Specify the file to parse. This must be a csv file. Preferably one generated by emetric, though it shouldn't really matter. If no file specified, then a file chooser window will appear. You need a file, if you don't provide one, this tool just exits.

Definition of Interesting: if the standard deviation of a column is > 0. (There is some change in the value.)

I am trying to find a way to make this tool useful for comparing more than two metrics.
"""


class SelectWin:
    def __init__(self, interesting, data):
        self.interesting = interesting
        self.data = data
        self.have_graphs=False
        self.pretty_cnt = 0
        self.keys_plot = []
        self.tick_key = ""
        self.colors = ['b','g','r','c','m','y','k']
        self.shapes = ['.',',','o','v','^','<','>','1','2','3','4','s','p',
                       '*','h','H','+','x','D','d','|','_']
                       

        #figure out which tick name to use, should make tick name
        #more findable, e.g. tick
        for tn in ['sys_tick','ejd_tick','mnesia_tick']:
            if tn in interesting:
                self.tick_key=tn
                break
            

        self.window = gtk.Window(gtk.WINDOW_TOPLEVEL)
        self.window.set_title("The Ugly Voalte Prettiness Maker")
        self.window.connect("delete_event",self.delete_event)

        vbox = gtk.VBox(True,2)
        self.window.add(vbox)

        bplot = gtk.Button("Plot")
        bplot.connect("clicked",self.plot)
        vbox.pack_start(bplot,True,True,2)
        bplot.show()


        for i in self.interesting:
            butt = gtk.CheckButton(i.replace("_"," "))
            butt.connect("toggled", self.toggle_interest, i)
            vbox.pack_start(butt, True, True, 2)
            butt.show()


        vbox.show()
        self.window.show()

    def delete_event(self, widget, event, data=None):
        gtk.main_quit()
        return False

    def toggle_interest(self, widget, data=None):
        print "%s toggled to %s"%(data,("off","on")[widget.get_active()])

        if not widget.get_active():
            #remove data from list if exists
            try:
                del self.keys_plot[self.keys_plot.index(data)]
            except ValueError,err:
                pass
        else:
            self.keys_plot.append(data)


    def plot(self,widget,data=None):
        self.create_plot()

        
    def create_plot(self):
        self.pretty_cnt = self.pretty_cnt+1
        line_style = itertools.product(self.shapes,self.colors)

        def next_style():
            s = list(next(line_style))
            s.reverse()
            return s
        if self.have_graphs:
            plt.clf()
        else:
            self.have_graphs = True

        fig = plt.figure()
        sp = fig.add_subplot(111)
        sp.set_title("Voalte Pretty %d"%(self.pretty_cnt,))
        sp.set_xlabel("ticks (s)")

        xs = self.data[self.tick_key]
        for k,i in zip(self.keys_plot,range(0,len(self.keys_plot))):
            ys = self.data[k]
            st = next_style()
            sp.plot(xs,ys,"%s%s"%(st[0],st[1]))
            sp.set_ylabel(k,color=st[0])
            for tl in sp.get_yticklabels():
                tl.set_color(st[0])
            if i == 0:
                sp = sp.twinx()

        plt.show()
            
            
            
        





def extract_interesting(options):
    data_recs  = mlab.csv2rec(options["data"])
    rv=[]

    for k,v in data_recs.dtype.fields.iteritems():
        try:#note that datetime will raise
            s = data_recs[k].std()
            if s > 0:
                rv.append(k)
        except TypeError,e:
            pass  #non number type, e.g. date
    return (rv,data_recs)
            


def ask_for_file():
    fs = gtk.FileChooserDialog("Open..",None,
                               gtk.FILE_CHOOSER_ACTION_OPEN,
                               (gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL,
                                gtk.STOCK_OPEN, gtk.RESPONSE_OK))
    fs.set_default_response(gtk.RESPONSE_OK)
    filter = gtk.FileFilter()
    filter.set_name("All files")
    filter.add_pattern("*.*")
    fs.add_filter(filter)

    filter = gtk.FileFilter()
    filter.set_name("CSV")
    filter.add_pattern("*.csv")
    fs.add_filter(filter)

    response = fs.run()
    if response == gtk.RESPONSE_OK:
        rv = (0,fs.get_filename())
    else:
        rv = (1,"")
    fs.destroy()
    return rv




def get_options(argv):
    if argv is None:
        argv = sys.argv
    


    try:
        try:
            opts,args = getopt.getopt(argv[1:], "hd:",
                                      ["help","data="])
        except getopt.error,msg:
            raise Usage(msg)
    except Usage,err:
        print >>sys.stderr,err.msg
        print >>sys.stderr," for help use --help"
        return (1,{})

    config = {"data":""}
    for o,a in opts:
        if o in ("-h","--help"):
            print usage()
            return (2,{})
        if o in ("-d","--data"):
            config["data"] = a
            
    return (0,config)
        
    
def main(argv=None):
    rv,options = get_options(argv)
    if rv: return rv #we die if there was a problem

    if "data" not in options:
        rv,options["data"] = ask_for_file()
        if rv: return rv

    (interesting,data) = extract_interesting(options)
    selwin = SelectWin(interesting,data)
    gtk.main()
    return 0

if __name__ == "__main__":
    sys.exit(main())

    
