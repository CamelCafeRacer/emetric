#!/usr/bin/env python
import os
import sys
import getopt
import itertools
import pygtk
pygtk.require('2.0')
import gtk


import numpy as np
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt
from matplotlib import mlab
from matplotlib.ticker import EngFormatter

class Usage(Exception):
    def __init__(self,msg):
        self.msg = msg
def usage():
    return """
plotr.py [options]

This will display a list of 'interesting' fields in which you can compare in line graphs.  It works best when you only compare two metrics. If you try for more, then good luck.

-h|--help:
    print this help message

-d file|--data=file :
    Specify the file to parse. This must be a csv file. Preferably one generated by emetric, though it shouldn't really matter. If no file specified, then a file chooser window will appear. You need a file, if you don't provide one, this tool just exits.

Definition of Interesting: if the standard deviation of a column is > 0. (There is some change in the value.)

I am trying to find a way to make this tool useful for comparing more than two metrics.
"""


class SelectWin:
    def __init__(self, interesting, data):
        self.interesting = interesting
        self.data = data
        self.have_graphs=False
        self.pretty_cnt = 0
        self.keys_plot = []
        self.tick_key = ""
        self.colors = ['b','g','r','c','m','y','k']
        self.shapes = ['.',',','o','v','^','<','>','1','2','3','4','s','p',
                       '*','h','H','+','x','D','d','|','_']
                       

        #figure out which tick name to use, should make tick name
        #more findable, e.g. tick
        for tn in ['sys_tick','ejd_tick','mnesia_tick']:
            if tn in interesting:
                self.tick_key=tn
                break
            

        self.window = gtk.Window(gtk.WINDOW_TOPLEVEL)
        self.window.set_title("The Ugly Voalte Prettiness Maker")
        self.window.connect("delete_event",self.delete_event)

        
        vcomp = gtk.VBox(True,2)
        self.window.add(vcomp)



        bplot = gtk.Button("Plot")
        bplot.connect("clicked",self.plot)
        vcomp.pack_start(bplot,True,True,2)
        bplot.show()


        cpivot = gtk.combo_box_new_text()
        cpivot.connect("changed",self.change_pivot)
        vcomp.pack_start(cpivot,True,True,2)

        for i in self.interesting:
            label = i.replace("_"," ")
            bcomp = gtk.CheckButton(label)
            bcomp.connect("toggled", self.toggle_interest, i)
            vcomp.pack_start(bcomp, True, True, 2)
            bcomp.show()

            cpivot.append_text(i)



        self.window.show_all()

    def delete_event(self, widget, event, data=None):
        gtk.main_quit()
        return False

    def toggle_interest(self, widget, data=None):
        if not widget.get_active():
            #remove data from list if exists
            try:
                del self.keys_plot[self.keys_plot.index(data)]
            except ValueError,err:
                pass
        else:
            self.keys_plot.append(data)

    def change_pivot(self,widget):
        model = widget.get_model()
        index = widget.get_active()
        if index >= 0:
            self.pivot = model[index][0]


    def plot(self,widget,data=None):
        self.create_plot()

        
    def create_plot(self):
        self.pretty_cnt = self.pretty_cnt+1

        # simple combinitorial product of shapes and colors so we can
        # iterate over them. matlib likes things such as 'r.' and
        # 'g-', etc.. 
        line_style = itertools.product(self.shapes,self.colors)
        def next_style():
            s = list(next(line_style))
            s.reverse()
            return s

        #hacky toggle, cause if we clear the plot state, we end up
        #with am extra window        
        if self.have_graphs:
            plt.clf()
        else:
            self.have_graphs = True

        kp = self.keys_plot# just to make it easier to reference

        fig = plt.figure()
        plt.subplots_adjust(hspace=0.01)


        x_set= self.data[self.tick_key]
        pivot_set = self.data[self.pivot]
        color_pivot,shape_pivot = next_style()

        labels_to_hide=[]

        for k,i in zip(kp, range(0,len(kp))):

            sp = fig.add_subplot(len(kp),1,i+1)
            sp.set_xlabel("ticks (s)")

            plt.bar(x_set,pivot_set)#,color_pivot+shape_pivot)
            sp.set_ylabel(self.pivot,color=color_pivot)
            for tl in sp.get_yticklabels():
                tl.set_color(color_pivot)

            y_set = self.data[k]
            color_y,shape_y = next_style()
            ax2 = sp.twinx()
            ax2.plot(x_set,y_set,color_y+shape_y)
            ax2.set_ylabel(k,color=color_y)
            for tl in ax2.get_yticklabels():
                tl.set_color(color_y)

            #hid all but the last ones
            if i < len(kp):
                labels_to_hide.append(sp.get_xticklabels())

        plt.setp(labels_to_hide,visible=False)


        plt.show()
            
            
            
        





def extract_interesting(options):
    data_recs  = mlab.csv2rec(options["data"])
    rv=[]

    for k,v in data_recs.dtype.fields.iteritems():
        try:#note that datetime will raise
            s = data_recs[k].std()
            if s > 0:
                rv.append(k)
        except TypeError,e:
            pass  #non number type, e.g. date
    return (rv,data_recs)
            


def ask_for_file():
    fs = gtk.FileChooserDialog("Open..",None,
                               gtk.FILE_CHOOSER_ACTION_OPEN,
                               (gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL,
                                gtk.STOCK_OPEN, gtk.RESPONSE_OK))
    fs.set_default_response(gtk.RESPONSE_OK)
    filter = gtk.FileFilter()
    filter.set_name("All files")
    filter.add_pattern("*.*")
    fs.add_filter(filter)

    filter = gtk.FileFilter()
    filter.set_name("CSV")
    filter.add_pattern("*.csv")
    fs.add_filter(filter)

    response = fs.run()
    if response == gtk.RESPONSE_OK:
        rv = (0,fs.get_filename())
    else:
        rv = (1,"")
    fs.destroy()
    return rv




def get_options(argv):
    if argv is None:
        argv = sys.argv
    


    try:
        try:
            opts,args = getopt.getopt(argv[1:], "hd:",
                                      ["help","data="])
        except getopt.error,msg:
            raise Usage(msg)
    except Usage,err:
        print >>sys.stderr,err.msg
        print >>sys.stderr," for help use --help"
        return (1,{})

    config = {"data":""}
    for o,a in opts:
        if o in ("-h","--help"):
            print usage()
            return (2,{})
        if o in ("-d","--data"):
            config["data"] = a
            
    return (0,config)
        
    
def main(argv=None):
    rv,options = get_options(argv)
    if rv: return rv #we die if there was a problem

    if "data" not in options:
        rv,options["data"] = ask_for_file()
        if rv: return rv

    (interesting,data) = extract_interesting(options)
    selwin = SelectWin(interesting,data)
    gtk.main()
    return 0

if __name__ == "__main__":
    sys.exit(main())

    
